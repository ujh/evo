#!/usr/bin/env ruby
require 'bundler/setup'
require 'open3'
require 'optparse'
Bundler.require(:default)

options = {}
OptionParser.new do |parser|
  parser.banner = "Usage: ./stats [options] experiment-name"

  parser.on("--csv", "Return CSV to stdout instead of table") do |v|
    options[:csv] = true
  end
end.parse!

experiment_name = ARGV.first

if experiment_name.nil?
  puts "Name of experiment required as argument!"
  exit 1
end

Dir.chdir("experiments/#{experiment_name}")

def median(array)
  return nil if array.empty?

  sorted = array.sort
  len = sorted.length
  n = (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0
  n.round(0) == n ? n.to_i : n
end

def average(array)
  return nil if array.empty?

  total = array.sum
  (total.to_f / array.length).round
end

$stats = File.exist?("stats.json") ? JSON.load_file("stats.json") : {}
$starting = true

def stats_for(generation)
  return $stats[generation] if $stats[generation]

  Dir.chdir(generation) do
    data = JSON.load_file("data.json")
    external_engines = data['players'].keys.find_all {|p| data['players'][p]['external'] }
    game_lengths = []
    wins = external_engines.each_with_object({}) {|player, hash| hash[player] = Hash.new {|h,k| h[k] = 0 }}

    Dir["*.dat"].each do |file_name|
      file_name =~ /(\w+)x(\w+)R/
      black = $1
      black += ".ann" unless data['players'][black]
      white = $2
      white += ".ann" unless data['players'][white]
      result = File.readlines(file_name).last.split
      winner = result[3].start_with?('B') ? black : white
      opponent = winner == black ? white : black
      game_length = result[6].to_i
      if !data['players'][winner]['external'] && data['players'][opponent]['external']
        wins[opponent][winner] += 1
      end
      game_lengths << game_length
    end

    stdout, stderr, status = Open3.capture3('find . -name "*.dat" -print | tar cvfj data.tar.bz2 -T -')
    if status.success?
      FileUtils.rm(Dir["*.dat"])
    else
      puts "Failed to tar *.dat files"
      puts stdout
      puts stderr
      exit(1)
    end

    game_length_stats = {
      'min' => game_lengths.min,
      'max' => game_lengths.max,
      'median' => median(game_lengths),
      'average' => average(game_lengths)
    }

    win_stats = wins.keys.each_with_object({}) do |external_engine, hash|
      hash[external_engine] = {
        'total' => wins[external_engine].values.sum,
        'max' => wins[external_engine].values.max,
        'median' => median(wins[external_engine].values),
        'average' => median(wins[external_engine].values),
        'rank' => data['ranking'].index {|e| e['name'] == external_engine},
        'all_ranks' => data['ranking'].length
      }
    end

    $stats[generation] = {
      'generation' => generation,
      'game_length_stats' => game_length_stats,
      'win_stats' => win_stats,
      'rounds' => data['round']
    }
  end

  File.open("stats.json", "w") {|f| f.puts JSON.pretty_generate($stats)}

  if ENV['NTFY_EVO_STATS'] && !$starting
    gen_stats = $stats[generation]
    win_stats = gen_stats['win_stats']
    msg = ["Gen: #{generation}"] + win_stats.map do |name, data|
      "#{name}: #{(data['total'].to_f/gen_stats['rounds']*100).round}% (#{data['rank']+1})"
    end
    msg = msg.join(" ")
    `curl -s -d "#{msg}" ntfy.sh/#{ENV['NTFY_EVO_STATS']}`
  end

  $stats[generation]
end

previous_generations = nil

def flatten_hash(param, prefix=nil)
  param.each_pair.reduce({}) do |a, (k, v)|
    v.is_a?(Hash) ? a.merge(flatten_hash(v, "#{prefix}#{k}.")) : a.merge("#{prefix}#{k}".to_sym => v)
  end
end

loop do
  generations = Dir["*"].find_all {|f| File.directory?(f)}.uniq.sort_by {|d| d.to_i }
  if generations == previous_generations
    sleep(5)
    next
  end

  gens = if options[:csv]
    generations[0..-2]
  else
    generations[0..-2].reverse.take(40).reverse
  end

  stats = gens.map do |generation|
    stats_for(generation)
  end

  if options[:csv]
    headings = flatten_hash(stats.last).keys
    output_string =  CSV.generate do |csv|
      csv << headings
      stats.each do |s|
        flattened = flatten_hash(s)
        csv << headings.map {|k| flattened[k] }
      end
    end

    puts output_string
    break
  else
    headings = ['Generation'] + stats.last['win_stats'].keys.flat_map {|n| [n, n, n]}
    rows = stats.map do |s|
      [s['generation']] + s['win_stats'].values.flat_map do |v|
        percentage = (v['total'].to_f/s['rounds']*100).round
        [v['total'], "#{percentage}%", "#{v['rank']+1}/#{v['all_ranks']}"]
      end
    end

    table = Terminal::Table.new(headings: headings, rows: rows)
    headings.each_with_index do |_h, i|
      table.align_column(i, :right)
    end

    puts "\033[2J\033[H"
    puts table

    sleep(5)
    $starting = false
    previous_generations = generations
  end
end
